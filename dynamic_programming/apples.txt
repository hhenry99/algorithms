from itertools import combinations

def compute_cost(selected_clusters, n, distances):
    """Compute the total cost given a set of selected clusters."""
    total_cost = 0
    for i in range(n):
        min_distance = min(distances[i][c] for c in selected_clusters)
        total_cost += min_distance
    return total_cost

def solve(index, k, selected_clusters, n, distances):
    """Recursive function that finds the minimum cost and the best cluster selection."""
    # Base case: If no clusters left to place, compute and return cost
    if k == 0:
        return compute_cost(selected_clusters, n, distances), selected_clusters.copy()
    
    # Base case: If we run out of points to consider, return infinity (invalid case)
    if index >= n:
        return float('inf'), set()

    # Option 1: Skip the current index
    cost_skip, clusters_skip = solve(index + 1, k, selected_clusters, n, distances)

    # Option 2: Place a cluster at index
    selected_clusters.add(index)
    cost_pick, clusters_pick = solve(ind ex + 1, k - 1, selected_clusters, n, distances)
    selected_clusters.remove(index)  # Backtrack

    # Return the option with the minimum cost
    if cost_pick < cost_skip:
        return cost_pick, clusters_pick
    else:
        return cost_skip, clusters_skip

# Example input (small case)
n = 4  # Number of points
k = 2  # Number of clusters to place

# Distance matrix (shortest arc length between points in a cycle)
distances = [
    [0, 1, 2, 1],  # Distances from x1
    [1, 0, 1, 2],  # Distances from x2
    [2, 1, 0, 1],  # Distances from x3
    [1, 2, 1, 0]   # Distances from x4
]

# Start the recursion
min_cost, best_clusters = solve(0, k, set(), n, distances)
min_cost, best_clusters
